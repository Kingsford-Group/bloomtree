\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage{secdot}

\title{Sequence Bloom Tree v0.3 User Guide}
\author{Brad Solomon and Carl Kingsford}
\begin{document}
\maketitle

\section{Synopsis}

SBT is a program that will allow you to index a set of short-read sequencing experiments and then query them quickly for a given sequence. The first step to use SBT is to create such an index. This is done via the ``hashes'', ``count'',  ``build'', and ``compress'' commands. Then you can query that index for any sequence to find the files in which that sequence likely appears.

If you use SBT, please cite:
\begin{itemize}
\item Brad Solomon and Carl Kingsford.
Large-Scale Search of Transcriptomic Read Sets with Sequence Bloom Trees. 
bioRxiv, 2015. doi: http://dx.doi.org/10.1101/017087
\end{itemize}

\section{Analysis Pipeline Overview}

To build and query a dataset using SBT, you should follow this general pipeline:
\begin{enumerate}
\item You first initialize the hash functions by running ``hashes'' command. 
\item Convert each fasta file in the database to a bloom filter bit vector using the  ``count`` command. 
\item Compile a list of all the bit vectors generated and build the SBT for that set using the ``build`` command.
\item Compress the bit vectors that make up the entire tree using the built in ``compress`` command.
\item Save your input queries as a line-separated text file and run the ``query`` command with the desired threshold and using the compressed SBT file.
\end{enumerate}
More details are given below.

\section{Analysis Pipeline Details}

You first initialize the hash functions by running ``hashes'' command. The parameter \verb+-k+ sets the kmer index size (default 20), and the parameter \verb+nb_hashes+ sets the number of hash functions to use. A typical value for this is $1$:
%
\begin{quote}
\begin{verbatim}
bt hashes [-k 20] hashfile nb_hashes
\end{verbatim}
\end{quote}

Next, you count the kmers in each of your input fastq/fasta files using the ``count'' subcommand; this will produce a bloom filter for the given file:
%
\begin{quote}
\begin{verbatim}
bt count hashfile bf_size fasta_in filter_out.bf.bv
\end{verbatim}
\end{quote}
%
Here \verb+hashfile+ is the hashfile output by the ``hashes'' command. \verb+bf_size+ gives the bloom filter size. This will depend on the number of kmers in your input file. It must be the SAME for all files that you are putting into the same SBT. If you have lots of files on which to build a SBT, you should write a little script that uses the above command to create a bloom filter for each. Something like:
%
\begin{quote}
\begin{verbatim}
for f in *.fasta ; do 
    bt count hashfile bf_size $f `basename $f .fasta`.bf.bv
done
\end{verbatim}
\end{quote}

Now, create a list of the \verb+.bf.bv+ files that you just created as text file with one filename per line (using, say, \verb+ls *.bf.bv > listoffiles.txt+) and call the ``build'' subcommand:
\begin{quote}
\begin{verbatim}
bt build [--sim-type 0] hashfile filterlistfile outfile
\end{verbatim}
\end{quote}
Here, \verb+filterlistfile+ is a list of the \verb+.bf.bv+ files. \verb+sim-type+ is an advanced command that changes the rule for where the files are inserted into the tree. After building (which may take some time), \verb+outfile+ will contain the data about the tree, and there will be many more \verb+.bf.bv+ files created. 

Finally, you must compress the tree to query it:
\begin{quote}
\begin{verbatim}
bt compress bloomtreefile outfile
\end{verbatim}
\end{quote}
This will create a compressed version of the tree which you can then query.

You can issue a query by putting 1 query sequence per line in a query text file and using the ``query'' subcommand:
\begin{quote}
\begin{verbatim}
bt query [--max-filters 1] [-t 0.8] [--leaf-only 0] bloomtreefile queryfile outfile
\end{verbatim}
\end{quote}
Here, \verb+-t+ gives the sensitivity threshold: the number of kmers that must be present for a query to be found. Values closer to 1 reduce the number of false positives. 

The ``check'', ``draw'', and ``sim'' subcommands can be used to carry out more specialized tasks. See details below.

\section{Command Descriptions}

\subsection{Hashes} 
\textit{bt hashes [-k 20] hashfile nb\_hashes}
\begin{itemize}
\item \textbf{hashfile} is the location of the file being written
\item \textbf{nb\_hashes} is an integer that sets the number of hashes generated for the bloom filters
\end{itemize}
\textbf{Usage:}

To build a set of conserved hash functions for the bloom filters, use a command like: \\

\textit{bt hashes myhashfile.hh 1} \\

This will write a file 'myhashfile.hh' which stores the necessary information for the Jellyfish library's bloom filter functions.

\subsection{Count}
\textit{bt count hashfile bf\_size fasta\_in filter\_out.bf.bv}
\begin{itemize}
\item \textbf{hashfile} is the location of the hashfile written using the ``hashes`` function
\item \textbf{fasta\_in} is the location of the input fasta being counted
\item \textbf{filter\_out.bf.bv} is the location of the bloom filter being written
\end{itemize}
\textbf{Usage:}

To convert a fasta short-read file to a SBT bit vector, use a command like: \\

\textit{bt count myhashfile.hh 2000000000 SRR001.fasta SRR0001.bf.bv} \\

This will count and hash the k-mers associated with 'SRR001.fasta' using the settings defined by 'myhashfile.hh' and store all k-mers in 'SRR0001.bf.bv'

\subsection{Build}
\textit{bt build [--sim-type 0] hashfile filterlistfile outfile}
\begin{itemize}
\item \textbf{sim-type} is an option that defines the similarity metric used. (0) uses the default Hamming distance between two bit vectors while (1) uses a Jaccard index metric.
\item \textbf{hashfile} is the location of the hashfile written using the ``hashes`` function
\item \textbf{filterlistfile} is the location of a plaintext file containing the paths to all the bit vectors generated by the ``count`` function
\item \textbf{outfile} is the location of the SBT structure file being written
\end{itemize}
\textbf{Usage:}

To build the bloomtree from a list of SBT bit vectors, use a command like: \\

\textit{bt build myhashfile.hh mybitvectorlist.txt mySBT.bloomtree} \\

This will build the SBT through single-threaded insertions of each element in 'mybitvectorlist.txt' and write the union filters to the same directory as the leaves. Once the tree is completely built, the edge-relationships that define the tree will be saved to 'mySBT.bloomtree'.

\subsection{Compress}
\textit{bt compress bloomtreefile outfile}
\begin{itemize}
\item \textbf{bloomtreefile} is the location of the SBT structure file written by the ``build`` function
\item \textbf{outfile} is the location of the [compressed] SBT structure file being written
\end{itemize}
\textbf{Usage:}

To compress the bloomtree from bit vectors to rrr compressed vectors, use a command like: \\

\textit{bt compress mySBT.bloomtree myCompressedSBT.bloomtree} \\

This will compress every file in the original SBT and write a new bloomtree using the same edge-relationships but the rrr compressed files.


\subsection{Query}
\textit{bt query [--max-filters 1] [-t 0.8] [--leaf-only 0] bloomtreefile queryfile outfile}
\begin{itemize}
\item \textbf{max-filters} is an option that defines the total number of filters that can be loaded at one time into memory. As filters are loaded only once per query, one filter is usually sufficient for single-threaded operations.
\item \textbf{threshold (t)} is a float between 0 and 1 that defines the proportion of query k-mers that must be present in any bloom filter to define a ``hit``. The default value assumes a valid hit contains 80\% of exact-matching k-mers.
\item \textbf{leaf-only} has two possible values. (0) is the default value and searches the entire SBT while (1) ignores the tree structure and queries just the leaf nodes of the tree in a naive search.
\item \textbf{bloomtreefile} is the location of the SBT structure file written by the ``build`` function
\item \textbf{queryfile} is the location of a text file containing line-separated full-length sequences.
\item \textbf{outfile} is the location of the [compressed] SBT structure file being written
\end{itemize}
\textbf{Usage:}

To query the SBT for an arbitrary set of sequences, use a command like: \\

\textit{bt query -t 0.8 mySBT.bloomtree myQueryFile.txt myOutFile.txt} \\

This will batch query the bloom tree encoded by 'mySBT.bloomtree' for every line-separated sequence in 'myQueryFile.txt' at a query k-mer threshold of 0.8. If your query of interest is a housekeeping gene or is known to be expressed in the majority of files, it may be beneficial to set the 'leaf\_only' option to 1 and ignore the tree structure by querying only the tree leaves. 


\subsection{Check}
\textit{bt check bloomtreefile}
\begin{itemize}
\item \textbf{bloomtreefile} is the location of the SBT structure file written by the ``build`` function
\end{itemize}
\textbf{Usage:}

To check that the tree was built and saved correctly such that every parent is the union of its two children, run the built-in check function: \\

\textit{bt check mySBT.bloomtree} \\

This will write a verbose set of output for each parent-child relationship in the function.

\subsection{Draw}
\textit{bt draw bloomtreefile out.dot}
\begin{itemize}
\item \textbf{bloomtreefile} is the location of the SBT structure file written by the ``build`` function
\item \textbf{out.dot} is the location of the graphvis file being written
\end{itemize}
\textbf{Usage:}

To graph the existing bloom tree structure, use a command like: \\

\textit{bt draw mySBT.bloomtree mySBTstructure.dot} \\

This will construct a .dot relationship of all nodes and edges that can be plotted using any number of graph visualization packages. % XXX: We recommend what? 


% XXX: Convert is depricated from when we used jfbloomfilters and isn't worth talking about.
\subsection{Sim}
\textit{bt sim [--sim-type 0] hashfile bvfile1 bvfile2}
\begin{itemize}
\item \textbf{sim-type} is an option that defines the similarity metric used. (0) uses the default Hamming distance between two bit vectors while (1) uses a Jaccard index metric.
\item \textbf{hashfile} is the location of the hashfile written using the ``hashes`` function
\item \textbf{bvfile1, bvfile2} are any combination of two SBT bit vectors constructed using the ``count`` function.
\end{itemize}
\textbf{Usage:}

To test the raw bit similarity between two bloom filters encoded by the SBT, use a command like: \\

\textit{bt sim hashfile.hh SRR0001.bf.bv SRR0002.bf.bv} \\

This will return the similarity using either the default Hamming (0) or Jaccard (1) metrics.

\end{document}